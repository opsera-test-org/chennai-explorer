name: Dev Deploy (11-Stage v2.4)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      grype_mode:
        description: 'Grype scan mode'
        required: false
        default: 'warn'
        type: choice
        options:
          - warn
          - block

env:
  APP_NAME: chenaiexpo
  TENANT: opsera
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev
  NAMESPACE: opsera-chenaiexpo-dev

jobs:
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 1: Security Scan (Gitleaks - Warn-Only)
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  security-scan:
    name: "ğŸ”’ Stage 1: Security Scan"
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Run Gitleaks
      uses: gitleaks/gitleaks-action@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Security Scan Complete
      if: always()
      run: |
        echo "âœ… Security scan completed (warn-only mode)"

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 2: Build Image (Local Only - No Push)
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  build-image:
    name: "ğŸ—ï¸ Stage 2: Build Image"
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: always()
    permissions:
      contents: read
      id-token: write
    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
      ecr_uri: ${{ steps.ecr.outputs.uri }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Set ECR URI
      id: ecr
      run: |
        ECR_URI="${{ steps.account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.TENANT }}-${{ env.APP_NAME }}"
        echo "uri=$ECR_URI" >> $GITHUB_OUTPUT
        echo "âœ… ECR URI: $ECR_URI"
    
    - name: Generate Image Tag
      id: meta
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "âœ… Image Tag: $IMAGE_TAG"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build Docker Image (No Push)
      uses: docker/build-push-action@v6
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: |
          ${{ steps.ecr.outputs.uri }}:${{ steps.meta.outputs.tag }}
          ${{ steps.ecr.outputs.uri }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        outputs: type=docker,dest=/tmp/image.tar
    
    - name: Upload Image Artifact
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: /tmp/image.tar
        retention-days: 1
    
    - name: Build Complete
      run: |
        echo "âœ… Image built successfully (not pushed yet)"
        echo "   Tag: ${{ steps.meta.outputs.tag }}"

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 3: Grype Vulnerability Scan
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  grype-scan:
    name: "ğŸ” Stage 3: Grype Scan"
    runs-on: ubuntu-latest
    needs: [build-image]
    continue-on-error: true
    permissions:
      contents: read
      security-events: write
    
    steps:
    - name: Download Image Artifact
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: /tmp
    
    - name: Load Docker Image
      run: |
        docker load --input /tmp/image.tar
        echo "âœ… Image loaded for scanning"
    
    - name: Run Grype Vulnerability Scan
      uses: anchore/scan-action@v6
      id: grype
      with:
        image: "${{ needs.build-image.outputs.ecr_uri }}:${{ needs.build-image.outputs.image_tag }}"
        fail-build: false
        severity-cutoff: high
        output-format: sarif
    
    - name: Upload Grype SARIF Report
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: ${{ steps.grype.outputs.sarif }}
    
    - name: Generate Grype Report
      if: always()
      run: |
        docker run --rm \
          -v /tmp/image.tar:/image.tar \
          anchore/grype:latest \
          docker-archive:/image.tar \
          -o table > grype-report.txt || true
        
        if [ -f grype-report.txt ]; then
          cat grype-report.txt
          echo "âœ… Grype scan completed (warn-only mode)"
        fi
    
    - name: Upload Grype Report Artifact
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: grype-report
        path: grype-report.txt
        retention-days: 30

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 4: Push to ECR
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  push-to-ecr:
    name: "ğŸ“¦ Stage 4: Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: always() && needs.build-image.result == 'success'
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Download Image Artifact
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: /tmp
    
    - name: Load Docker Image
      run: |
        docker load --input /tmp/image.tar
        echo "âœ… Image loaded"
    
    - name: Login to Amazon ECR
      id: ecr-login
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Push Image to ECR
      run: |
        ECR_URI="${{ needs.build-image.outputs.ecr_uri }}"
        IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
        
        docker push ${ECR_URI}:${IMAGE_TAG}
        docker push ${ECR_URI}:latest
        
        echo "âœ… Image pushed to ECR"
        echo "   URI: ${ECR_URI}:${IMAGE_TAG}"

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 5: Refresh ECR Secret on Spoke Cluster (BEFORE Manifests)
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  refresh-ecr-secret:
    name: "ğŸ” Stage 5: Refresh ECR Secret"
    runs-on: ubuntu-latest
    needs: [build-image, push-to-ecr]
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Configure kubectl for Spoke Cluster
      run: |
        aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
        kubectl config use-context arn:aws:eks:${{ env.AWS_REGION }}:${{ steps.account.outputs.account_id }}:cluster/${{ env.SPOKE_CLUSTER }}
    
    - name: Refresh ECR Secret
      run: |
        ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
        ECR_URI="${{ needs.build-image.outputs.ecr_uri }}"
        
        kubectl delete secret ecr-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true
        
        kubectl create secret docker-registry ecr-secret \
          --docker-server=$ECR_URI \
          --docker-username=AWS \
          --docker-password=$ECR_TOKEN \
          --namespace=${{ env.NAMESPACE }}
        
        echo "âœ… ECR secret refreshed on spoke cluster"

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 6: Update Manifests (Idempotent Git Operations)
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  update-manifests:
    name: "ğŸ“ Stage 6: Update Manifests"
    runs-on: ubuntu-latest
    needs: [build-image, push-to-ecr, refresh-ecr-secret]
    permissions:
      contents: write
      id-token: write
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Update Kustomization Image Tag
      run: |
        ECR_URI="${{ needs.build-image.outputs.ecr_uri }}"
        IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
        
        # Update base kustomization - ONLY newName and newTag fields
        sed -i "s|newName:.*|newName: $ECR_URI|g" k8s/base/kustomization.yaml
        sed -i "s|newTag:.*|newTag: $IMAGE_TAG|g" k8s/base/kustomization.yaml
        
        echo "âœ… Kustomization updated"
        echo "   ECR URI: $ECR_URI"
        echo "   Image Tag: $IMAGE_TAG"
    
    - name: Commit and Push Changes (Idempotent)
      run: |
        # Pull latest changes first
        git pull --rebase origin main || true
        
        # Check if there are changes to commit
        if git diff --quiet k8s/base/kustomization.yaml; then
          echo "No changes to commit"
        else
          git add k8s/base/kustomization.yaml
          git commit -m "chore(dev): update image tag to ${{ needs.build-image.outputs.image_tag }} [skip ci]"
          
          # Retry push with rebase on conflict
          max_retries=3
          retry_count=0
          while [ $retry_count -lt $max_retries ]; do
            if git push origin main; then
              echo "âœ… Changes pushed successfully"
              break
            else
              echo "Push failed, retrying with rebase..."
              git pull --rebase origin main
              retry_count=$((retry_count + 1))
            fi
          done
        fi

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 7: Create/Update ArgoCD Application (Mandatory)
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  create-argocd-app:
    name: "ğŸ¯ Stage 7: Create ArgoCD App"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        ref: main
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Configure kubectl for Hub Cluster
      run: |
        aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
        kubectl config use-context arn:aws:eks:${{ env.AWS_REGION }}:${{ steps.account.outputs.account_id }}:cluster/${{ env.HUB_CLUSTER }}
    
    - name: Create/Update ArgoCD Application
      run: |
        echo "Creating/Updating ArgoCD Application..."
        kubectl apply -f argocd/application-dev.yaml
        echo "âœ… ArgoCD Application created/updated"

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 8: ArgoCD Hard Refresh (Explicit)
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  argocd-refresh:
    name: "ğŸ”„ Stage 8: ArgoCD Refresh"
    runs-on: ubuntu-latest
    needs: [create-argocd-app]
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Configure kubectl for Hub Cluster
      run: |
        aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
        kubectl config use-context arn:aws:eks:${{ env.AWS_REGION }}:${{ steps.account.outputs.account_id }}:cluster/${{ env.HUB_CLUSTER }}
    
    - name: Hard Refresh ArgoCD Application
      run: |
        kubectl patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
          -n argocd \
          --type merge \
          -p '{"operation":{"initiatedBy":{"username":"github-actions"},"info":[{"name":"reason","value":"manifest-update"}]}}' || true
        
        kubectl annotate application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
          -n argocd \
          argocd.argoproj.io/refresh=hard \
          --overwrite
        
        echo "âœ… ArgoCD hard refresh triggered"
        sleep 5

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 9: Sync ArgoCD
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  argocd-sync:
    name: "âš¡ Stage 9: ArgoCD Sync"
    runs-on: ubuntu-latest
    needs: [argocd-refresh]
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Configure kubectl for Hub Cluster
      run: |
        aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
        kubectl config use-context arn:aws:eks:${{ env.AWS_REGION }}:${{ steps.account.outputs.account_id }}:cluster/${{ env.HUB_CLUSTER }}
    
    - name: Trigger ArgoCD Sync
      run: |
        kubectl patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
          -n argocd \
          --type merge \
          -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"revision":"HEAD"}}}' || true
        
        echo "âœ… ArgoCD sync triggered"
    
    - name: Wait for Sync to Complete
      run: |
        echo "Waiting for ArgoCD sync to complete..."
        max_wait=300
        elapsed=0
        
        while [ $elapsed -lt $max_wait ]; do
          SYNC_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
            -n argocd \
            -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          
          HEALTH_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
            -n argocd \
            -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          
          echo "Sync: $SYNC_STATUS | Health: $HEALTH_STATUS"
          
          if [[ "$SYNC_STATUS" == "Synced" ]]; then
            echo "âœ… ArgoCD sync completed"
            break
          fi
          
          sleep 10
          elapsed=$((elapsed + 10))
        done

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 10: Verify Deployment
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  verify-deployment:
    name: "âœ… Stage 10: Verify Deployment"
    runs-on: ubuntu-latest
    needs: [build-image, argocd-sync]
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Configure kubectl for Spoke Cluster
      run: |
        aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
        kubectl config use-context arn:aws:eks:${{ env.AWS_REGION }}:${{ steps.account.outputs.account_id }}:cluster/${{ env.SPOKE_CLUSTER }}
    
    - name: Wait for Deployment Rollout
      run: |
        echo "Waiting for deployment to complete..."
        kubectl rollout status deployment/${{ env.APP_NAME }} \
          -n ${{ env.NAMESPACE }} \
          --timeout=5m || true
    
    - name: Check Pod Status
      run: |
        echo "Pod Status:"
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
        
        # Check if pods are running
        RUNNING_PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} \
          --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l || echo "0")
        
        if [ "$RUNNING_PODS" -gt 0 ]; then
          echo "âœ… $RUNNING_PODS pod(s) running"
        else
          echo "âš ï¸  No running pods found"
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} || true
        fi
    
    - name: Verify Image Tag
      run: |
        DEPLOYED_IMAGE=$(kubectl get deployment/${{ env.APP_NAME }} \
          -n ${{ env.NAMESPACE }} \
          -o jsonpath='{.spec.template.spec.containers[0].image}')
        
        EXPECTED_TAG="${{ needs.build-image.outputs.image_tag }}"
        
        echo "Deployed Image: $DEPLOYED_IMAGE"
        echo "Expected Tag: $EXPECTED_TAG"
        
        if echo "$DEPLOYED_IMAGE" | grep -q "$EXPECTED_TAG"; then
          echo "âœ… Image tag verified"
        else
          echo "âš ï¸  Image tag mismatch"
        fi

  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # STAGE 11: Deployment Summary
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  deployment-summary:
    name: "ğŸ“Š Stage 11: Deployment Summary"
    runs-on: ubuntu-latest
    needs: [build-image, verify-deployment]
    if: always()
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
    
    - name: Configure kubectl for Spoke Cluster
      run: |
        aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
        kubectl config use-context arn:aws:eks:${{ env.AWS_REGION }}:${{ steps.account.outputs.account_id }}:cluster/${{ env.SPOKE_CLUSTER }}
    
    - name: Generate Deployment Summary
      run: |
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ‰ DEPLOYMENT SUMMARY - ${{ env.ENVIRONMENT }} ENVIRONMENT"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "ğŸ“¦ Deployment Details:"
        echo "   â€¢ Application: ${{ env.APP_NAME }}"
        echo "   â€¢ Environment: ${{ env.ENVIRONMENT }}"
        echo "   â€¢ Image Tag: ${{ needs.build-image.outputs.image_tag }}"
        echo "   â€¢ Namespace: ${{ env.NAMESPACE }}"
        echo "   â€¢ Cluster: ${{ env.SPOKE_CLUSTER }}"
        echo ""
        echo "ğŸ”— Resources:"
        echo "   â€¢ ArgoCD: https://${{ env.ARGOCD_SERVER }}/applications/${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
        echo "   â€¢ ECR: ${{ needs.build-image.outputs.ecr_uri }}"
        echo ""
        echo "ğŸ“Š Pod Status:"
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} || true
        echo ""
        echo "ğŸ” Service Status:"
        kubectl get svc -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} || true
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âœ… Deployment completed successfully!"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
